/*
ConvertBinary2(unsigned int Number, int Index) {
  return (Number >> Index) & 0x1; // This will trace what bit is at position index

  Number | 0b00001000; // This does an OR with the mask specified in 0b aka binary
  Number | (0x1 << 4); // This will do an OR between Number and 1 after one has been shifted 4 times to the left

  Number & 0b11110111; // Same as above but with end
  Number & ~0b00001000; // Same as above but with negation NOT
  Number | ~(0x1 << Index); // L:ogical OR but with moved by Index and a negation NOT
  
  
  // To clear all bits from the most significant bit through i (inclusive), we do:
int clearMSBthroughI(int num, int i) {
    int mask = (1 << i) - 1;
    return num & mask;
    //We could also shift around. If we know how many bits need to remove, we can shift to the left n elements, then shift back to the right and we will have 0s instead    
}

// To clear all bits from i through 0 (inclusive), we do:
int clearBitsIthrough0(int num, int i) {
    int mask = ~(((1 << (i+1)) - 1);
    return num & mask;
}

// To check two numbers bit by bit, if they are different at certain bit
 // right shift both the numbers by 'i' and 
        // check if the bit at the 0th position is different 
        if (((A >> i) & 1) != ((B >> i) & 1)) { 
            count++; 
  */
